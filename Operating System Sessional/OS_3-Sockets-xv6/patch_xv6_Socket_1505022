commit e47ecefb3a43c7ed977749bfac26a25e49d429c9
Author: Mahim1997 <1505022.mm@ugrad.cse.buet.ac.bd>
Date:   Sat Jan 19 20:37:17 2019 +0600

    Sat 8 45 pm

diff --git a/Makefile b/Makefile
index 09d790c..e011a93 100644
--- a/Makefile
+++ b/Makefile
@@ -16,12 +16,14 @@ OBJS = \
 	pipe.o\
 	proc.o\
 	sleeplock.o\
+	sock.o\
 	spinlock.o\
 	string.o\
 	swtch.o\
 	syscall.o\
 	sysfile.o\
 	sysproc.o\
+	syssock.o\
 	trapasm.o\
 	trap.o\
 	uart.o\
@@ -181,6 +183,7 @@ UPROGS=\
 	_usertests\
 	_wc\
 	_zombie\
+	_socktest\
 
 fs.img: mkfs README $(UPROGS)
 	./mkfs fs.img README $(UPROGS)
diff --git a/defs.h b/defs.h
index 82fb982..1cf12d7 100644
--- a/defs.h
+++ b/defs.h
@@ -121,6 +121,15 @@ int             wait(void);
 void            wakeup(void*);
 void            yield(void);
 
+// sock.c
+void            sinit(void);
+int             listen(int);
+int             connect(int, const char*);
+int             send(int, const char*, int);
+int             recv(int, char*, int);
+int             disconnect(int);
+//socket close er function ... 
+void            closeSockets(int);
 // swtch.S
 void            swtch(struct context**, struct context*);
 
diff --git a/main.c b/main.c
index 9924e64..ac0b23e 100644
--- a/main.c
+++ b/main.c
@@ -4,6 +4,7 @@
 #include "memlayout.h"
 #include "mmu.h"
 #include "proc.h"
+#include "sock.h"
 #include "x86.h"
 
 static void startothers(void);
@@ -27,10 +28,11 @@ main(void)
   consoleinit();   // console hardware
   uartinit();      // serial port
   pinit();         // process table
+  sinit();         // socket table
   tvinit();        // trap vectors
   binit();         // buffer cache
   fileinit();      // file table
-  ideinit();       // disk 
+  ideinit();       // disk
   startothers();   // start other processors
   kinit2(P2V(4*1024*1024), P2V(PHYSTOP)); // must come after startothers()
   userinit();      // first user process
diff --git a/param.h b/param.h
index a7e90ef..a507c00 100644
--- a/param.h
+++ b/param.h
@@ -1,3 +1,8 @@
+#include "socketThings.h"   //To include the error codes ...
+
+#define NPORT       128  // maximum number of ports
+#define NSOCK        32//2  // maximum number of sockets
+#define MAX_BUFFER_SIZE_SOCKET 128 // Max buffer size of the socket's char array ... (buffer)
 #define NPROC        64  // maximum number of processes
 #define KSTACKSIZE 4096  // size of per-process kernel stack
 #define NCPU          8  // maximum number of CPUs
diff --git a/proc.c b/proc.c
index 806b1b1..6ce4715 100644
--- a/proc.c
+++ b/proc.c
@@ -8,8 +8,8 @@
 #include "spinlock.h"
 
 struct {
-  struct spinlock lock;
-  struct proc proc[NPROC];
+    struct spinlock lock;
+    struct proc proc[NPROC];
 } ptable;
 
 static struct proc *initproc;
@@ -21,48 +21,49 @@ extern void trapret(void);
 static void wakeup1(void *chan);
 
 void
-pinit(void)
-{
-  initlock(&ptable.lock, "ptable");
+pinit(void) {
+    initlock(&ptable.lock, "ptable");
 }
 
 // Must be called with interrupts disabled
+
 int
 cpuid() {
-  return mycpu()-cpus;
+    return mycpu() - cpus;
 }
 
 // Must be called with interrupts disabled to avoid the caller being
 // rescheduled between reading lapicid and running through the loop.
+
 struct cpu*
-mycpu(void)
-{
-  int apicid, i;
-  
-  if(readeflags()&FL_IF)
-    panic("mycpu called with interrupts enabled\n");
-  
-  apicid = lapicid();
-  // APIC IDs are not guaranteed to be contiguous. Maybe we should have
-  // a reverse map, or reserve a register to store &cpus[i].
-  for (i = 0; i < ncpu; ++i) {
-    if (cpus[i].apicid == apicid)
-      return &cpus[i];
-  }
-  panic("unknown apicid\n");
+mycpu(void) {
+    int apicid, i;
+
+    if (readeflags() & FL_IF)
+        panic("mycpu called with interrupts enabled\n");
+
+    apicid = lapicid();
+    // APIC IDs are not guaranteed to be contiguous. Maybe we should have
+    // a reverse map, or reserve a register to store &cpus[i].
+    for (i = 0; i < ncpu; ++i) {
+        if (cpus[i].apicid == apicid)
+            return &cpus[i];
+    }
+    panic("unknown apicid\n");
 }
 
 // Disable interrupts so that we are not rescheduled
 // while reading proc from the cpu structure
+
 struct proc*
 myproc(void) {
-  struct cpu *c;
-  struct proc *p;
-  pushcli();
-  c = mycpu();
-  p = c->proc;
-  popcli();
-  return p;
+    struct cpu *c;
+    struct proc *p;
+    pushcli();
+    c = mycpu();
+    p = c->proc;
+    popcli();
+    return p;
 }
 
 //PAGEBREAK: 32
@@ -70,245 +71,256 @@ myproc(void) {
 // If found, change state to EMBRYO and initialize
 // state required to run in the kernel.
 // Otherwise return 0.
+
 static struct proc*
-allocproc(void)
-{
-  struct proc *p;
-  char *sp;
+allocproc(void) {
+    struct proc *p;
+    char *sp;
 
-  acquire(&ptable.lock);
+    acquire(&ptable.lock);
 
-  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-    if(p->state == UNUSED)
-      goto found;
+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+        if (p->state == UNUSED)
+            goto found;
 
-  release(&ptable.lock);
-  return 0;
+    release(&ptable.lock);
+    return 0;
 
 found:
-  p->state = EMBRYO;
-  p->pid = nextpid++;
+    p->state = EMBRYO;
+    p->pid = nextpid++;
 
-  release(&ptable.lock);
+    release(&ptable.lock);
 
-  // Allocate kernel stack.
-  if((p->kstack = kalloc()) == 0){
-    p->state = UNUSED;
-    return 0;
-  }
-  sp = p->kstack + KSTACKSIZE;
+    // Allocate kernel stack.
+    if ((p->kstack = kalloc()) == 0) {
+        p->state = UNUSED;
+        return 0;
+    }
+    sp = p->kstack + KSTACKSIZE;
 
-  // Leave room for trap frame.
-  sp -= sizeof *p->tf;
-  p->tf = (struct trapframe*)sp;
+    // Leave room for trap frame.
+    sp -= sizeof *p->tf;
+    p->tf = (struct trapframe*) sp;
 
-  // Set up new context to start executing at forkret,
-  // which returns to trapret.
-  sp -= 4;
-  *(uint*)sp = (uint)trapret;
+    // Set up new context to start executing at forkret,
+    // which returns to trapret.
+    sp -= 4;
+    *(uint*) sp = (uint) trapret;
 
-  sp -= sizeof *p->context;
-  p->context = (struct context*)sp;
-  memset(p->context, 0, sizeof *p->context);
-  p->context->eip = (uint)forkret;
+    sp -= sizeof *p->context;
+    p->context = (struct context*) sp;
+    memset(p->context, 0, sizeof *p->context);
+    p->context->eip = (uint) forkret;
 
-  return p;
+    return p;
 }
 
 //PAGEBREAK: 32
 // Set up first user process.
+
 void
-userinit(void)
-{
-  struct proc *p;
-  extern char _binary_initcode_start[], _binary_initcode_size[];
-
-  p = allocproc();
-  
-  initproc = p;
-  if((p->pgdir = setupkvm()) == 0)
-    panic("userinit: out of memory?");
-  inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);
-  p->sz = PGSIZE;
-  memset(p->tf, 0, sizeof(*p->tf));
-  p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
-  p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
-  p->tf->es = p->tf->ds;
-  p->tf->ss = p->tf->ds;
-  p->tf->eflags = FL_IF;
-  p->tf->esp = PGSIZE;
-  p->tf->eip = 0;  // beginning of initcode.S
-
-  safestrcpy(p->name, "initcode", sizeof(p->name));
-  p->cwd = namei("/");
-
-  // this assignment to p->state lets other cores
-  // run this process. the acquire forces the above
-  // writes to be visible, and the lock is also needed
-  // because the assignment might not be atomic.
-  acquire(&ptable.lock);
-
-  p->state = RUNNABLE;
-
-  release(&ptable.lock);
+userinit(void) {
+    struct proc *p;
+    extern char _binary_initcode_start[], _binary_initcode_size[];
+
+    p = allocproc();
+
+    initproc = p;
+    if ((p->pgdir = setupkvm()) == 0)
+        panic("userinit: out of memory?");
+    inituvm(p->pgdir, _binary_initcode_start, (int) _binary_initcode_size);
+    p->sz = PGSIZE;
+    memset(p->tf, 0, sizeof (*p->tf));
+    p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
+    p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
+    p->tf->es = p->tf->ds;
+    p->tf->ss = p->tf->ds;
+    p->tf->eflags = FL_IF;
+    p->tf->esp = PGSIZE;
+    p->tf->eip = 0; // beginning of initcode.S
+
+    safestrcpy(p->name, "initcode", sizeof (p->name));
+    p->cwd = namei("/");
+
+    // this assignment to p->state lets other cores
+    // run this process. the acquire forces the above
+    // writes to be visible, and the lock is also needed
+    // because the assignment might not be atomic.
+    acquire(&ptable.lock);
+
+    p->state = RUNNABLE;
+
+    release(&ptable.lock);
 }
 
 // Grow current process's memory by n bytes.
 // Return 0 on success, -1 on failure.
+
 int
-growproc(int n)
-{
-  uint sz;
-  struct proc *curproc = myproc();
-
-  sz = curproc->sz;
-  if(n > 0){
-    if((sz = allocuvm(curproc->pgdir, sz, sz + n)) == 0)
-      return -1;
-  } else if(n < 0){
-    if((sz = deallocuvm(curproc->pgdir, sz, sz + n)) == 0)
-      return -1;
-  }
-  curproc->sz = sz;
-  switchuvm(curproc);
-  return 0;
+growproc(int n) {
+    uint sz;
+    struct proc *curproc = myproc();
+
+    sz = curproc->sz;
+    if (n > 0) {
+        if ((sz = allocuvm(curproc->pgdir, sz, sz + n)) == 0)
+            return -1;
+    } else if (n < 0) {
+        if ((sz = deallocuvm(curproc->pgdir, sz, sz + n)) == 0)
+            return -1;
+    }
+    curproc->sz = sz;
+    switchuvm(curproc);
+    return 0;
 }
 
 // Create a new process copying p as the parent.
 // Sets up stack to return as if from system call.
 // Caller must set state of returned proc to RUNNABLE.
+
 int
-fork(void)
-{
-  int i, pid;
-  struct proc *np;
-  struct proc *curproc = myproc();
-
-  // Allocate process.
-  if((np = allocproc()) == 0){
-    return -1;
-  }
+fork(void) {
+    int i, pid;
+    struct proc *np;
+    struct proc *curproc = myproc();
+
+    // Allocate process.
+    if ((np = allocproc()) == 0) {
+        return -1;
+    }
 
-  // Copy process state from proc.
-  if((np->pgdir = copyuvm(curproc->pgdir, curproc->sz)) == 0){
-    kfree(np->kstack);
-    np->kstack = 0;
-    np->state = UNUSED;
-    return -1;
-  }
-  np->sz = curproc->sz;
-  np->parent = curproc;
-  *np->tf = *curproc->tf;
+    // Copy process state from proc.
+    if ((np->pgdir = copyuvm(curproc->pgdir, curproc->sz)) == 0) {
+        kfree(np->kstack);
+        np->kstack = 0;
+        np->state = UNUSED;
+        return -1;
+    }
+    np->sz = curproc->sz;
+    np->parent = curproc;
+    *np->tf = *curproc->tf;
 
-  // Clear %eax so that fork returns 0 in the child.
-  np->tf->eax = 0;
+    // Clear %eax so that fork returns 0 in the child.
+    np->tf->eax = 0;
 
-  for(i = 0; i < NOFILE; i++)
-    if(curproc->ofile[i])
-      np->ofile[i] = filedup(curproc->ofile[i]);
-  np->cwd = idup(curproc->cwd);
+    for (i = 0; i < NOFILE; i++)
+        if (curproc->ofile[i])
+            np->ofile[i] = filedup(curproc->ofile[i]);
+    np->cwd = idup(curproc->cwd);
 
-  safestrcpy(np->name, curproc->name, sizeof(curproc->name));
+    safestrcpy(np->name, curproc->name, sizeof (curproc->name));
 
-  pid = np->pid;
+    pid = np->pid;
 
-  acquire(&ptable.lock);
+    acquire(&ptable.lock);
 
-  np->state = RUNNABLE;
+    np->state = RUNNABLE;
 
-  release(&ptable.lock);
+    release(&ptable.lock);
 
-  return pid;
+    return pid;
 }
 
 // Exit the current process.  Does not return.
 // An exited process remains in the zombie state
 // until its parent calls wait() to find out it exited.
+
 void
-exit(void)
-{
-  struct proc *curproc = myproc();
-  struct proc *p;
-  int fd;
-
-  if(curproc == initproc)
-    panic("init exiting");
-
-  // Close all open files.
-  for(fd = 0; fd < NOFILE; fd++){
-    if(curproc->ofile[fd]){
-      fileclose(curproc->ofile[fd]);
-      curproc->ofile[fd] = 0;
+exit(void) {
+    struct proc *curproc = myproc();
+    //Storing for sockClose
+    int socketClosePID = myproc()->pid;
+    //Done
+    struct proc *p;
+    int fd;
+
+    if (curproc == initproc)
+        panic("init exiting");
+
+    // Close all open files.
+    for (fd = 0; fd < NOFILE; fd++) {
+        if (curproc->ofile[fd]) {
+            fileclose(curproc->ofile[fd]);
+            curproc->ofile[fd] = 0;
+        }
     }
-  }
 
-  begin_op();
-  iput(curproc->cwd);
-  end_op();
-  curproc->cwd = 0;
+    begin_op();
+    iput(curproc->cwd);
+    end_op();
+    curproc->cwd = 0;
 
-  acquire(&ptable.lock);
+    acquire(&ptable.lock);
 
-  // Parent might be sleeping in wait().
-  wakeup1(curproc->parent);
+    // Parent might be sleeping in wait().
+    wakeup1(curproc->parent);
 
-  // Pass abandoned children to init.
-  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-    if(p->parent == curproc){
-      p->parent = initproc;
-      if(p->state == ZOMBIE)
-        wakeup1(initproc);
+    // Pass abandoned children to init.
+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
+        if (p->parent == curproc) {
+            p->parent = initproc;
+            if (p->state == ZOMBIE)
+                wakeup1(initproc);
+        }
     }
-  }
 
-  // Jump into the scheduler, never to return.
-  curproc->state = ZOMBIE;
-  sched();
-  panic("zombie exit");
+    //Added for socket close
+    closeSockets(socketClosePID);
+    //Added for socket close done 
+
+
+    // Jump into the scheduler, never to return.
+    curproc->state = ZOMBIE;
+    sched();
+
+
+
+    panic("zombie exit");
 }
 
 // Wait for a child process to exit and return its pid.
 // Return -1 if this process has no children.
+
 int
-wait(void)
-{
-  struct proc *p;
-  int havekids, pid;
-  struct proc *curproc = myproc();
-  
-  acquire(&ptable.lock);
-  for(;;){
-    // Scan through table looking for exited children.
-    havekids = 0;
-    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-      if(p->parent != curproc)
-        continue;
-      havekids = 1;
-      if(p->state == ZOMBIE){
-        // Found one.
-        pid = p->pid;
-        kfree(p->kstack);
-        p->kstack = 0;
-        freevm(p->pgdir);
-        p->pid = 0;
-        p->parent = 0;
-        p->name[0] = 0;
-        p->killed = 0;
-        p->state = UNUSED;
-        release(&ptable.lock);
-        return pid;
-      }
-    }
+wait(void) {
+    struct proc *p;
+    int havekids, pid;
+    struct proc *curproc = myproc();
 
-    // No point waiting if we don't have any children.
-    if(!havekids || curproc->killed){
-      release(&ptable.lock);
-      return -1;
+    acquire(&ptable.lock);
+    for (;;) {
+        // Scan through table looking for exited children.
+        havekids = 0;
+        for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
+            if (p->parent != curproc)
+                continue;
+            havekids = 1;
+            if (p->state == ZOMBIE) {
+                // Found one.
+                pid = p->pid;
+                kfree(p->kstack);
+                p->kstack = 0;
+                freevm(p->pgdir);
+                p->pid = 0;
+                p->parent = 0;
+                p->name[0] = 0;
+                p->killed = 0;
+                p->state = UNUSED;
+                release(&ptable.lock);
+                return pid;
+            }
+        }
+
+        // No point waiting if we don't have any children.
+        if (!havekids || curproc->killed) {
+            release(&ptable.lock);
+            return -1;
+        }
+
+        // Wait for children to exit.  (See wakeup1 call in proc_exit.)
+        sleep(curproc, &ptable.lock); //DOC: wait-sleep
     }
-
-    // Wait for children to exit.  (See wakeup1 call in proc_exit.)
-    sleep(curproc, &ptable.lock);  //DOC: wait-sleep
-  }
 }
 
 //PAGEBREAK: 42
@@ -319,40 +331,40 @@ wait(void)
 //  - swtch to start running that process
 //  - eventually that process transfers control
 //      via swtch back to the scheduler.
+
 void
-scheduler(void)
-{
-  struct proc *p;
-  struct cpu *c = mycpu();
-  c->proc = 0;
-  
-  for(;;){
-    // Enable interrupts on this processor.
-    sti();
-
-    // Loop over process table looking for process to run.
-    acquire(&ptable.lock);
-    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-      if(p->state != RUNNABLE)
-        continue;
-
-      // Switch to chosen process.  It is the process's job
-      // to release ptable.lock and then reacquire it
-      // before jumping back to us.
-      c->proc = p;
-      switchuvm(p);
-      p->state = RUNNING;
-
-      swtch(&(c->scheduler), p->context);
-      switchkvm();
-
-      // Process is done running for now.
-      // It should have changed its p->state before coming back.
-      c->proc = 0;
-    }
-    release(&ptable.lock);
+scheduler(void) {
+    struct proc *p;
+    struct cpu *c = mycpu();
+    c->proc = 0;
+
+    for (;;) {
+        // Enable interrupts on this processor.
+        sti();
+
+        // Loop over process table looking for process to run.
+        acquire(&ptable.lock);
+        for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
+            if (p->state != RUNNABLE)
+                continue;
+
+            // Switch to chosen process.  It is the process's job
+            // to release ptable.lock and then reacquire it
+            // before jumping back to us.
+            c->proc = p;
+            switchuvm(p);
+            p->state = RUNNING;
+
+            swtch(&(c->scheduler), p->context);
+            switchkvm();
+
+            // Process is done running for now.
+            // It should have changed its p->state before coming back.
+            c->proc = 0;
+        }
+        release(&ptable.lock);
 
-  }
+    }
 }
 
 // Enter scheduler.  Must hold only ptable.lock
@@ -362,173 +374,173 @@ scheduler(void)
 // be proc->intena and proc->ncli, but that would
 // break in the few places where a lock is held but
 // there's no process.
+
 void
-sched(void)
-{
-  int intena;
-  struct proc *p = myproc();
-
-  if(!holding(&ptable.lock))
-    panic("sched ptable.lock");
-  if(mycpu()->ncli != 1)
-    panic("sched locks");
-  if(p->state == RUNNING)
-    panic("sched running");
-  if(readeflags()&FL_IF)
-    panic("sched interruptible");
-  intena = mycpu()->intena;
-  swtch(&p->context, mycpu()->scheduler);
-  mycpu()->intena = intena;
+sched(void) {
+    int intena;
+    struct proc *p = myproc();
+
+    if (!holding(&ptable.lock))
+        panic("sched ptable.lock");
+    if (mycpu()->ncli != 1)
+        panic("sched locks");
+    if (p->state == RUNNING)
+        panic("sched running");
+    if (readeflags() & FL_IF)
+        panic("sched interruptible");
+    intena = mycpu()->intena;
+    swtch(&p->context, mycpu()->scheduler);
+    mycpu()->intena = intena;
 }
 
 // Give up the CPU for one scheduling round.
+
 void
-yield(void)
-{
-  acquire(&ptable.lock);  //DOC: yieldlock
-  myproc()->state = RUNNABLE;
-  sched();
-  release(&ptable.lock);
+yield(void) {
+    acquire(&ptable.lock); //DOC: yieldlock
+    myproc()->state = RUNNABLE;
+    sched();
+    release(&ptable.lock);
 }
 
 // A fork child's very first scheduling by scheduler()
 // will swtch here.  "Return" to user space.
+
 void
-forkret(void)
-{
-  static int first = 1;
-  // Still holding ptable.lock from scheduler.
-  release(&ptable.lock);
-
-  if (first) {
-    // Some initialization functions must be run in the context
-    // of a regular process (e.g., they call sleep), and thus cannot
-    // be run from main().
-    first = 0;
-    iinit(ROOTDEV);
-    initlog(ROOTDEV);
-  }
-
-  // Return to "caller", actually trapret (see allocproc).
+forkret(void) {
+    static int first = 1;
+    // Still holding ptable.lock from scheduler.
+    release(&ptable.lock);
+
+    if (first) {
+        // Some initialization functions must be run in the context
+        // of a regular process (e.g., they call sleep), and thus cannot
+        // be run from main().
+        first = 0;
+        iinit(ROOTDEV);
+        initlog(ROOTDEV);
+    }
+
+    // Return to "caller", actually trapret (see allocproc).
 }
 
 // Atomically release lock and sleep on chan.
 // Reacquires lock when awakened.
+
 void
-sleep(void *chan, struct spinlock *lk)
-{
-  struct proc *p = myproc();
-  
-  if(p == 0)
-    panic("sleep");
-
-  if(lk == 0)
-    panic("sleep without lk");
-
-  // Must acquire ptable.lock in order to
-  // change p->state and then call sched.
-  // Once we hold ptable.lock, we can be
-  // guaranteed that we won't miss any wakeup
-  // (wakeup runs with ptable.lock locked),
-  // so it's okay to release lk.
-  if(lk != &ptable.lock){  //DOC: sleeplock0
-    acquire(&ptable.lock);  //DOC: sleeplock1
-    release(lk);
-  }
-  // Go to sleep.
-  p->chan = chan;
-  p->state = SLEEPING;
-
-  sched();
-
-  // Tidy up.
-  p->chan = 0;
-
-  // Reacquire original lock.
-  if(lk != &ptable.lock){  //DOC: sleeplock2
-    release(&ptable.lock);
-    acquire(lk);
-  }
+sleep(void *chan, struct spinlock *lk) {
+    struct proc *p = myproc();
+
+    if (p == 0)
+        panic("sleep");
+
+    if (lk == 0)
+        panic("sleep without lk");
+
+    // Must acquire ptable.lock in order to
+    // change p->state and then call sched.
+    // Once we hold ptable.lock, we can be
+    // guaranteed that we won't miss any wakeup
+    // (wakeup runs with ptable.lock locked),
+    // so it's okay to release lk.
+    if (lk != &ptable.lock) { //DOC: sleeplock0
+        acquire(&ptable.lock); //DOC: sleeplock1
+        release(lk);
+    }
+    // Go to sleep.
+    p->chan = chan;
+    p->state = SLEEPING;
+
+    sched();
+
+    // Tidy up.
+    p->chan = 0;
+
+    // Reacquire original lock.
+    if (lk != &ptable.lock) { //DOC: sleeplock2
+        release(&ptable.lock);
+        acquire(lk);
+    }
 }
 
 //PAGEBREAK!
 // Wake up all processes sleeping on chan.
 // The ptable lock must be held.
+
 static void
-wakeup1(void *chan)
-{
-  struct proc *p;
+wakeup1(void *chan) {
+    struct proc *p;
 
-  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-    if(p->state == SLEEPING && p->chan == chan)
-      p->state = RUNNABLE;
+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+        if (p->state == SLEEPING && p->chan == chan)
+            p->state = RUNNABLE;
 }
 
 // Wake up all processes sleeping on chan.
+
 void
-wakeup(void *chan)
-{
-  acquire(&ptable.lock);
-  wakeup1(chan);
-  release(&ptable.lock);
+wakeup(void *chan) {
+    acquire(&ptable.lock);
+    wakeup1(chan);
+    release(&ptable.lock);
 }
 
 // Kill the process with the given pid.
 // Process won't exit until it returns
 // to user space (see trap in trap.c).
+
 int
-kill(int pid)
-{
-  struct proc *p;
-
-  acquire(&ptable.lock);
-  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-    if(p->pid == pid){
-      p->killed = 1;
-      // Wake process from sleep if necessary.
-      if(p->state == SLEEPING)
-        p->state = RUNNABLE;
-      release(&ptable.lock);
-      return 0;
+kill(int pid) {
+    struct proc *p;
+
+    acquire(&ptable.lock);
+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
+        if (p->pid == pid) {
+            p->killed = 1;
+            // Wake process from sleep if necessary.
+            if (p->state == SLEEPING)
+                p->state = RUNNABLE;
+            release(&ptable.lock);
+            return 0;
+        }
     }
-  }
-  release(&ptable.lock);
-  return -1;
+    release(&ptable.lock);
+    return -1;
 }
 
 //PAGEBREAK: 36
 // Print a process listing to console.  For debugging.
 // Runs when user types ^P on console.
 // No lock to avoid wedging a stuck machine further.
+
 void
-procdump(void)
-{
-  static char *states[] = {
-  [UNUSED]    "unused",
-  [EMBRYO]    "embryo",
-  [SLEEPING]  "sleep ",
-  [RUNNABLE]  "runble",
-  [RUNNING]   "run   ",
-  [ZOMBIE]    "zombie"
-  };
-  int i;
-  struct proc *p;
-  char *state;
-  uint pc[10];
-
-  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-    if(p->state == UNUSED)
-      continue;
-    if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
-      state = states[p->state];
-    else
-      state = "???";
-    cprintf("%d %s %s", p->pid, state, p->name);
-    if(p->state == SLEEPING){
-      getcallerpcs((uint*)p->context->ebp+2, pc);
-      for(i=0; i<10 && pc[i] != 0; i++)
-        cprintf(" %p", pc[i]);
+procdump(void) {
+    static char *states[] = {
+        [UNUSED] "unused",
+        [EMBRYO] "embryo",
+        [SLEEPING] "sleep ",
+        [RUNNABLE] "runble",
+        [RUNNING] "run   ",
+        [ZOMBIE] "zombie"
+    };
+    int i;
+    struct proc *p;
+    char *state;
+    uint pc[10];
+
+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
+        if (p->state == UNUSED)
+            continue;
+        if (p->state >= 0 && p->state < NELEM(states) && states[p->state])
+            state = states[p->state];
+        else
+            state = "???";
+        cprintf("%d %s %s", p->pid, state, p->name);
+        if (p->state == SLEEPING) {
+            getcallerpcs((uint*) p->context->ebp + 2, pc);
+            for (i = 0; i < 10 && pc[i] != 0; i++)
+                cprintf(" %p", pc[i]);
+        }
+        cprintf("\n");
     }
-    cprintf("\n");
-  }
 }
diff --git a/shell.txt b/shell.txt
new file mode 100755
index 0000000..9ee428d
--- /dev/null
+++ b/shell.txt
@@ -0,0 +1,4 @@
+clear
+make clean
+make
+make qemu
diff --git a/sock.c b/sock.c
new file mode 100644
index 0000000..1eb065f
--- /dev/null
+++ b/sock.c
@@ -0,0 +1,517 @@
+#include "types.h" 
+#include "defs.h"
+#include "param.h"
+#include "spinlock.h"
+#include "memlayout.h"
+#include "mmu.h"
+#include "x86.h"  
+#include "sock.h"
+#include "proc.h"
+
+
+// A structure to maintain a list of sockets
+// Should it have locking? [Yes?? To access while ** connect, listen, recv, send **  are being called ... ]
+
+struct {
+    struct spinlock lock;
+    struct socket sock[NSOCK];
+    int local_ports_used[NPORT]; //0->available, 1->used ... no need for double loop
+    //print the whole socket table ...
+} stable;
+
+
+// ----------------------------------------------------- Util functions begin --------------------------------------------------
+// Util functions to return socket
+
+static struct socket*
+getSocket_LocalPort(int lport) {
+    struct socket *s;
+    for (s = stable.sock; s < &stable.sock[NSOCK]; s++) {
+        if (s->localPort == lport) {
+            return s;
+        }
+    }
+    return 0;
+}
+
+static struct socket*
+getSocket_RemotePort(int port) {
+    struct socket *s;
+    for (s = stable.sock; s < &stable.sock[NSOCK]; s++) {
+        if (s->remotePort == port) {
+            return s;
+        }
+    }
+    return 0;
+}
+// Using functions to return socket
+
+char*
+mystrcopy(char *s, const char *t, int n) { //taken from safestrcpy from string.c
+    char *os;
+
+    os = s;
+    if (n <= 0)
+        return os;
+    while (--n > 0 && (*s++ = *t++) != 0)
+        ;
+    *s = 0;
+    return os;
+}
+
+void printSocket(struct socket* s) {
+    cprintf("Socket's localPort = %d, remotePort = %d, state = %d, owner = %d, has_data = %d\n",
+            s->localPort, s->remotePort, s->socket_state, s->owner_process_ID, s->has_data);
+}
+
+// ----------------------------------------------------- Util functions end --------------------------------------------------
+
+//Initialisation
+
+void
+sinit(void) {
+
+
+#if DEBUG_SOCKET == 1
+    cprintf("\n\n\n--->> sinit() function is called .... initlock(sTable) will be called ... \n");
+    cprintf("Printing initial stable ... \n");
+#endif
+
+    initlock(&stable.lock, "stable"); //Initialise lock 
+    struct socket *sIter;
+
+    //Acquire Lock
+    acquire(&stable.lock);
+    for (sIter = stable.sock; sIter < &stable.sock[NSOCK]; sIter++) {
+        sIter->socket_state = CLOSED;
+    }
+    int x;
+    for (x = 0; x < NPORT; x++) {
+        stable.local_ports_used[x] = 0; //0 -> available , 1 -> used 
+    }
+    release(&stable.lock);
+    //Release Lock
+
+    cprintf("\n\n");
+}
+
+/*
+    struct socket *sIter;
+    acquire(&stable.lock);
+    for (sIter = stable.sock; sIter < &stable.sock[NSOCK]; sIter++)
+    {
+        
+    }
+    release(&stable.lock);
+ */
+
+//Listen function ... 
+
+int
+listen(int lPort) {
+
+    int status = 0;
+
+#if DEBUG_SOCKET == 1
+    cprintf("Inside listen system call on lport = %d\n", lPort);
+#endif
+
+    //Error Checking ... Check if lPort already exists in stable or not ... 
+    struct socket *sIter;
+    acquire(&stable.lock);
+
+
+    for (sIter = stable.sock; sIter < &stable.sock[NSOCK]; sIter++) {
+        //If table has an entry with localPort == lPort , then report an error [ Sir er kon error ?? ] 
+        if (sIter->localPort == lPort) {
+            status = E_ACCESS_DENIED; //Since some other process had opened as local port so THIS process is not the owner
+        }
+    }
+    struct socket *unusedSocket = 0;
+    if (status == 0) {
+        //Socket table does NOT have this lPort as local port so ... we assign any unused/CLOSED socket with this config ...
+        for (unusedSocket = stable.sock; unusedSocket < &stable.sock[NSOCK]; unusedSocket++) {
+            if (unusedSocket->socket_state == CLOSED) {
+                unusedSocket->localPort = lPort; //Make localPort = parameter's lPort
+                unusedSocket->remotePort = lPort; //For simplicity, make remote port also same as localPort
+                unusedSocket->socket_state = LISTENING; //Make state as listening.
+                unusedSocket->owner_process_ID = myproc()->pid; //sys_getpid() ?? Access paay na //Assign as the calling process's pid ??
+                unusedSocket->buffer[0] = '\0';
+                stable.local_ports_used[lPort] = 1; //Make that local port as 1 ...
+#if DEBUG_SOCKET == 1
+                cprintf("UNUSED SOCKET FOUND , Printing that socket ... !!!\n");
+                printSocket(unusedSocket);
+#endif
+                break;
+            }
+        }
+    }
+    release(&stable.lock);
+
+
+#if DEBUG_SOCKET == 1
+    cprintf("Returning the status = %d \n\n\n", status);
+#endif
+
+    return status;
+}
+
+int
+connect(int rport, const char* host) {
+    //host check was already resolved in sys_connect 
+
+    //Search the stable for local port available and then connect as remote port <-> rport and return that local port ??
+
+    int iter = 0, lPortFound = -1;
+    struct socket *sIter;
+    acquire(&stable.lock);
+    //Initial checking
+
+
+    int willUse = 0;
+    for (sIter = stable.sock; sIter<&stable.sock[NSOCK]; sIter++) {
+        if (sIter->localPort == rport) {
+            if ((sIter->remotePort == rport) && (sIter->socket_state == LISTENING)) {
+                willUse = 1;
+                break;
+            } else {
+                //Already before a connection was established so ... this should be a access_denied error
+#if DEBUG_SOCKET == 1
+                cprintf("The remote socket with rport = %d was not in listening state, release and return E_ACCESS_DENIED\n\n", rport);
+#endif
+                release(&stable.lock);
+                return E_ACCESS_DENIED;
+
+            }
+        }
+
+    }
+    if (willUse == 0) {
+#if DEBUG_SOCKET == 1
+        cprintf("Socket with rport = %d does not exist in sTable\n\n", rport);
+#endif  
+        release(&stable.lock);
+        return E_NOTFOUND;
+    }
+    for (iter = NPORT - 1; iter >= 0; iter--) {
+        if (stable.local_ports_used[iter] == 0) {
+            lPortFound = iter; //Local port unused is found 
+            break;
+        }
+    }
+
+    int newSocketFound = -1;
+#if DEBUG_SOCKET == 1
+    cprintf("In connect(serverPort = %d), localPort found = %d\n", rport, lPortFound);
+#endif
+    for (sIter = stable.sock; sIter < &stable.sock[NSOCK]; sIter++) {
+        //Now lets try to find an UNUSED Socket ... otherwise return E_FAIL
+        if (sIter->socket_state == CLOSED && lPortFound != -1) {
+            //Found a CLOSED Socket , assign local port and remote port accordingly .. 
+
+            stable.local_ports_used[lPortFound] = 1; //Make local port array of that idx as 1 .. since it will be in use 
+            sIter->socket_state = CONNECTED;
+            sIter->localPort = lPortFound;
+            sIter->remotePort = rport;
+            sIter->owner_process_ID = myproc()->pid;
+#if DEBUG_SOCKET == 1
+            cprintf("In connect(serverPort = %d), CLOSED socket found, printing new assigned socket...\n", rport);
+            printSocket(sIter);
+#endif            
+            newSocketFound = 1;
+            break;
+        }
+    }
+    if (newSocketFound == 1) {
+        //Fix the local port of the server side
+        for (sIter = stable.sock; sIter < &stable.sock[NSOCK]; sIter++) {
+            if (sIter->localPort == rport) {
+                sIter->remotePort = lPortFound;
+                sIter->socket_state = CONNECTED;
+#if DEBUG_SOCKET == 1
+                cprintf("Inside connect(serverPort = %d), After changing server socket, printing it\n", rport);
+                printSocket(sIter);
+#endif                
+                release(&stable.lock);
+                cprintf("\n\n");
+                return lPortFound;
+            }
+        }
+    }
+    cprintf("\n\n");
+    release(&stable.lock);
+    return E_FAIL; //Cannot find a CLOSED socket since all are booked !!
+}
+
+int
+send(int lport, const char* data, int n) {
+    //Find the corresponding remote port of localport = lport 
+    //Call sleep(localSocket) for itself, and wakeUp(remoteSocket) for the counterpart recv() 
+    //1. Find the socket -> localPort == lport
+    struct socket* localSocket = 0;
+    struct socket* remoteSocket = 0;
+
+    acquire(&stable.lock);
+    localSocket = getSocket_LocalPort(lport);
+    remoteSocket = getSocket_RemotePort(lport);
+
+#if DEBUG_SOCKET == 1
+    //    cprintf("Inside send() function  of lport = %d, pid = %d\n", lport, myproc()->pid);
+#endif
+    //Either Sockets do not exist, return E_NOTFOUND error
+    if (!localSocket) {
+#if DEBUG_SOCKET == 1
+        cprintf("Local Socket does not exist in the stable, return E_NOTFOUND error\n\n");
+#endif
+        release(&stable.lock);
+        return E_NOTFOUND;
+    }
+    if (!remoteSocket) {
+#if DEBUG_SOCKET == 1
+        cprintf("Remote Socket does not exist in the stable, return E_NOTFOUND error\n\n");
+#endif
+        release(&stable.lock);
+        return E_NOTFOUND;
+    }
+
+    //Checking owner process ID MISMATCH occurs ...
+    if (localSocket->owner_process_ID != myproc()->pid) {
+#if DEBUG_SOCKET == 1
+        cprintf("Process ID Mismatch occures, owner id of local sock = %d, and myPID = %d, release and return E_ACCESS_DENIED error.\n\n",
+                localSocket->owner_process_ID, myproc()->pid);
+#endif
+        release(&stable.lock);
+        return E_ACCESS_DENIED;
+    }
+#if DEBUG_SOCKET == 1
+    cprintf("In send() , Both sockets found ... printing local and then remote socket\n");
+    printSocket(localSocket);
+    printSocket(remoteSocket);
+#endif
+
+    //Checking if any of the sockets is not in connected state
+    if (localSocket->socket_state != CONNECTED) {
+#if DEBUG_SOCKET == 1
+        cprintf("Local Socket is not in CONNECTED State, return E_WRONG_STATE error\n\n");
+#endif
+        release(&stable.lock);
+        return E_WRONG_STATE;
+    }
+    if (remoteSocket->socket_state != CONNECTED) {
+#if DEBUG_SOCKET == 1
+        cprintf("Remote Socket is not in CONNECTED State, return E_WRONG_STATE error\n\n");
+#endif
+        release(&stable.lock);
+        return E_WRONG_STATE;
+    }
+    int flag = 0;
+    //Everything looks OK up until now , check for whether the remote socket has data or not
+    while (remoteSocket->has_data == 1) {
+        if (flag == 0) {
+#if DEBUG_SOCKET == 1
+            cprintf("Remote Socket has data == 1, so sleep ... on the channel localSocket\n");
+#endif
+            flag = 1;
+        }
+        //remote socket has data, so should sleep until that data is CLEARED 
+        sleep(localSocket, &stable.lock); //Channel1 is the local socket for send
+    }
+    //Sleeping/Polling is over ...
+    mystrcopy(remoteSocket->buffer, data, n); //Copy the data , memcpy teh header include e problem ase
+    remoteSocket->has_data = 1; //Set has_data
+
+#if DEBUG_SOCKET == 1
+    cprintf("[Polling over] Data is written to remoteSocket [local = %d, remote = %d, data = %s] and calling wakeup\n\n",
+            remoteSocket->localPort, remoteSocket->remotePort, remoteSocket->buffer);
+#endif
+    //Wake up the remoteSocket [Channel2 for recv]
+    wakeup(remoteSocket);
+    release(&stable.lock);
+
+    return 0;
+}
+
+int
+recv(int lport, char* data, int n) {
+    //Counterpart send -> sleep(localSocket) so in here should wakeUp(remoteSocket)
+    //Counterpart send -> wakeup(remoteSocket) so in here should sleep(localSocket)
+    struct socket* localSocket = 0;
+    struct socket* remoteSocket = 0;
+    acquire(&stable.lock);
+    localSocket = getSocket_LocalPort(lport);
+    remoteSocket = getSocket_RemotePort(lport); //Check using if remote port of [server]Socket == [this/local] port
+
+#if DEBUG_SOCKET == 1
+    //    cprintf("Inside recv() of lport = %d, pid = %d\n", lport, myproc()->pid);
+#endif
+
+    //Check 1. If either sockets do not exist
+    if ((!localSocket) || (!remoteSocket)) {
+#if DEBUG_SOCKET == 1
+        cprintf("Either of the Local or Remote Socket does not exist in the sTable, release and return E_NOTFOUND error\n\n");
+#endif
+        release(&stable.lock);
+        return E_NOTFOUND;
+    }
+
+    //Check 2. If owner of LOCAL SOCKET mismatch
+    if (localSocket->owner_process_ID != myproc()->pid) {
+#if DEBUG_SOCKET == 1
+        cprintf("Local socket owner id = %d and myproc->id = %d, MISMATCH occurs, so release and return E_ACCESS_DENIED error\n\n",
+                localSocket->owner_process_ID, myproc()->pid);
+#endif
+        release(&stable.lock);
+        return E_ACCESS_DENIED;
+    }
+
+#if DEBUG_SOCKET == 1
+    cprintf("Both sockets found ... further checking needed, printing local and remote\n");
+    printSocket(localSocket);
+    printSocket(remoteSocket);
+#endif
+
+    //Check 3. Not in CONNECTED state either of them ... return E_WRONG_STATE error
+    if ((localSocket->socket_state != CONNECTED) || (remoteSocket->socket_state != CONNECTED)) {
+#if DEBUG_SOCKET == 1
+        cprintf("Either of local or remote socket is not in the connected state so release and return E_WRONG_STATE error\n\n");
+#endif
+        release(&stable.lock);
+        return E_WRONG_STATE;
+    }
+
+    //So far everything OK, now check if there is NO data present in LOCAL_SOCKET , if no data , go to sleep [Server Side]
+    int flag = 0;
+    while (localSocket->has_data == 0) {
+        //No data in local socket, go to sleep
+        if (flag == 0) {
+#if DEBUG_SOCKET == 1
+            cprintf("Local Socket has_data == 0 so sleeping on the channel localSocket [Server Side] \n\n");
+            flag = 1;
+#endif
+        }
+        sleep(localSocket, &stable.lock);
+    }
+
+
+    //Now has_data = 1 
+    //This is where we have data [in server side] , retrieve the data to this char * in the parameter and make has_data = 0.
+#if DEBUG_SOCKET == 1
+    cprintf("Copying data to buf from localSocket->buffer, making local->hasData = 0 ,and calling wakeUp(remoteSocket) in recv \n\n");
+#endif 
+
+    mystrcopy(data, localSocket->buffer, n);
+    localSocket->has_data = 0;
+    wakeup(remoteSocket); //Counter part remote socket i.e. client's local socket is being woken up since has_data (local side) = 0
+
+    release(&stable.lock);
+
+    return 0;
+}
+
+int
+disconnect(int lport) {
+    //Check 1. if socket with this Local Port does exist or not
+    struct socket *localSocket;
+
+    acquire(&stable.lock);
+
+    localSocket = getSocket_LocalPort(lport);
+    if (!localSocket) {
+#if DEBUG_SOCKET == 1
+        cprintf("Local Socket with lport %d does not exist in table so release table and return E_NOTFOUND\n", lport);
+#endif
+        release(&stable.lock);
+        return E_NOTFOUND;
+    }
+    if (localSocket->owner_process_ID != myproc()->pid) {
+#if DEBUG_SOCKET == 1
+        cprintf("PROCESS MISMATCH in disconnect () , Local Socket process id = %d, and myprocess pid = %d, mismatch, release and return E_ACCESS_DENIED\n",
+                localSocket->owner_process_ID, myproc()->pid);
+#endif
+        release(&stable.lock);
+        return E_ACCESS_DENIED;
+    }
+    struct socket* remoteSocket = getSocket_RemotePort(localSocket->localPort);
+
+    if (remoteSocket) {
+        //This local socket is connected to a remote socket  
+#if DEBUG_SOCKET == 1
+        cprintf("In disconnect() , Local Socket IS connected to a remote socket, printing them (l , r) and changing to CLOSED in local\n");
+        printSocket(localSocket);
+        printSocket(remoteSocket);
+#endif
+        localSocket->socket_state = CLOSED;
+        localSocket->remotePort = 0;
+        localSocket->localPort = 0;
+
+        localSocket->has_data = 0; // ?? Closed means that data is now useless so should be has_data = 0
+        localSocket->owner_process_ID = 0; ///Owner process also doesn't matter now
+        stable.local_ports_used[lport] = 0; //Make it available now ...
+        remoteSocket->remotePort = remoteSocket->localPort; //Make remote socket as server ... i.e. make remote socket's local port the same as remote port
+        wakeup(remoteSocket); //To make sure if other side's socket which went into sleep eg. due to recv() then it should wake up
+
+
+    } else {
+        //Local Socket is NOT connected to a remote socket
+#if DEBUG_SOCKET == 1
+        cprintf("Local Socket is NOT connected to a remote socket ... just change its state to CLOSED and make port available\n");
+#endif
+        localSocket->socket_state = CLOSED;
+        localSocket->localPort = 0;
+        localSocket->remotePort = 0;
+        localSocket->has_data = 0;
+
+        stable.local_ports_used[lport] = 0;
+        localSocket->owner_process_ID = 0;
+    }
+
+
+    release(&stable.lock);
+
+    return 0;
+}
+
+//Additional function ... closeSocket for process abrupt crashing
+
+void closeSockets(int processID) {
+    //TODO
+#if DEBUG_SOCKET == 1
+    cprintf("==>>>Calling closeSockets ... for processID = %d\n", processID);
+#endif
+    //Check all sockets in stable with owner = process ID and make them CLOSED ...
+    struct socket *s;
+    acquire(&stable.lock);
+    for (s = stable.sock; s < &stable.sock[NSOCK]; s++) {
+        if (s->owner_process_ID == processID && s->socket_state != CLOSED) {
+#if DEBUG_SOCKET == 1
+            cprintf("Printing socket to close ... \n");
+            printSocket(s);
+#endif
+            stable.local_ports_used[s->localPort] = 0;
+            struct socket *remote = getSocket_RemotePort(s->localPort);
+            s->has_data = 0;
+            s->localPort = 0;
+            s->remotePort = 0;
+            s->owner_process_ID = 0;
+            s->socket_state = CLOSED;
+            if (remote) {
+                remote->remotePort = remote->localPort;
+                //                wakeup(s);   //wake up dile trap khay for some reason ..
+                //        remote->socket_state = CLOSED ; // ???
+            }
+        }
+    }
+#if PRINT_FINALLY_ALL_SOCKET == 1
+    cprintf("-->>In closeSockets() .. Printing all sockets ... \n");
+    for (s = stable.sock; s < &stable.sock[NSOCK]; s++) {
+        printSocket(s);
+    }
+    cprintf("\n\n");
+#endif
+    release(&stable.lock);
+}
+
+
+
+
+
diff --git a/sock.h b/sock.h
new file mode 100644
index 0000000..03058f9
--- /dev/null
+++ b/sock.h
@@ -0,0 +1,17 @@
+#include "param.h"  //For MAX_BUFFER_SIZE_SOCKET
+//
+// DONE: Define an enumeration to represent socket state.
+//
+enum sockstate {CLOSED, LISTENING, CONNECTED}; 
+
+//
+// DONE: Define a structure to represent a socket.
+//
+struct socket{
+    int localPort;  //Local port
+    int remotePort; // Remote Port 
+    char buffer[MAX_BUFFER_SIZE_SOCKET];   //This is in param.h
+    int owner_process_ID ; // the process's pid 
+    enum sockstate socket_state;   //The state of the socket ... 
+    int has_data ;  // 1 -> means it has data ... , 0 -> means it does not have data 
+};
\ No newline at end of file
diff --git a/socketThings.h b/socketThings.h
new file mode 100644
index 0000000..38d10ca
--- /dev/null
+++ b/socketThings.h
@@ -0,0 +1,15 @@
+//For now kept here
+#define E_NOTFOUND -1025
+#define E_ACCESS_DENIED -1026
+#define E_WRONG_STATE -1027
+#define E_FAIL -1028
+#define E_INVALID_ARG -1029
+
+
+//For now kept here
+//#define E_LISTEN_ERROR -1000
+
+#define DEBUG_SOCKET 0
+#define ERROR_HANDLING 1
+#define ABRUPT_ENDING 0
+#define PRINT_FINALLY_ALL_SOCKET 0
\ No newline at end of file
diff --git a/socktest.c b/socktest.c
new file mode 100644
index 0000000..a6e3f65
--- /dev/null
+++ b/socktest.c
@@ -0,0 +1,362 @@
+#include "types.h"
+#include "user.h"
+
+//int serverPort = 10;
+
+int checkError(int givenInteger) {
+    if (givenInteger == E_NOTFOUND) {
+        printf(1, "--->> Error in Accessing a socket that is not in the stable\n");
+    } else if (givenInteger == E_ACCESS_DENIED) {
+        printf(1, "--->> Error in Accessing a socket from wrong process\n");
+    } else if (givenInteger == E_WRONG_STATE) {
+        printf(1, "--->> Error in Attempting to send or receive, when the socket is not connected\n");
+    } else if (givenInteger == E_FAIL) {
+        printf(1, "--->> Error in no more socket opening (limit exceeded)\n");
+    } else if (givenInteger == E_INVALID_ARG) {
+        printf(1, "--->> Error in Parameter issues\n");
+    }
+    return givenInteger;
+}
+
+void clientProc(int serverPort) {
+    int clientPort;
+    char buf[128];
+    char host[16] = "localhost";
+
+    // sleep for 100 clock ticks to ensure that the server process starts first.
+    sleep(100);
+
+    printf(1, "Client>> pid = %d, Attempting to connect to port %d, host %s ...\n", getpid(), serverPort, host);
+    clientPort = connect(serverPort, host); // [ Here the socket of server oitao connected, client socket also connected ]
+
+    sleep(20);
+    printf(1, "Client>> pid = %d, connect() returned %d\n", getpid(), clientPort);
+    clientPort = checkError(clientPort);
+
+    while (1) {
+
+#if ERROR_HANDLING == 1
+        if (clientPort < 0) {
+            break;
+        }
+#endif
+        printf(1, "Client pid = %d>>  Enter text to send to server: ", getpid());
+        gets(buf, sizeof (buf));
+        buf[strlen(buf) - 1] = '\0'; // Eliminating the '\n'
+        printf(1, "Client pid = %d, Message to send : %s\n", getpid(), buf);
+        int x = send(clientPort, buf, strlen(buf) + 1);
+        printf(1, "Client pid = %d, send() returned %d\n", getpid(), x);
+        if (0 == strcmp(buf, "exit")) {
+            printf(1, "Client pid = %d, exiting...\n\n", getpid());
+#if ABRUPT_ENDING == 1
+            break; //break without calling disconnect ... 
+#endif
+            disconnect(clientPort);
+            break;
+        }
+
+        sleep(100 + uptime() % 100);
+
+        recv(clientPort, buf, sizeof (buf));
+        printf(1, "Client pid = %d>> Received: \"%s\"\n\n", getpid(), buf);
+    }
+}
+
+void serverProc(int serverPort) {
+    int status;
+    char buf[128];
+
+    printf(1, "Server pid = %d >> Starting to listen at port %d ...\n", getpid(), serverPort);
+    status = listen(serverPort); // ke message ta pathaitese ami actually jantesi na .. [EIKHANE LISTENING]
+    printf(1, "Server pid = %d >> listen() returned %d\n", getpid(), status);
+    status = checkError(status);
+
+    while (1) {
+        sleep(100 + uptime() % 100);
+
+        recv(serverPort, buf, sizeof (buf));
+        printf(1, "Server pid = %d >> Received: \"%s\"\n\n", getpid(), buf);
+
+        if (0 == strcmp(buf, "exit")) {
+            printf(1, "Server pid = %d, exiting...\n", getpid());
+#if ABRUPT_ENDING == 1
+            break;
+#endif
+            disconnect(serverPort);
+            break;
+        }
+
+        sleep(100 + uptime() % 100);
+
+        strcpy(buf + strlen(buf), " <OK>");
+        send(serverPort, buf, strlen(buf) + 1); // ??? should send to clientPort (by using stable) 
+    }
+}
+
+void integer_to_string(char * string, int number) {
+
+    if (number == 0) {
+        string[0] = '0';
+        return;
+    };
+    int divide = 0;
+    int modResult;
+    int length = 0;
+    int isNegative = 0;
+    int copyOfNumber;
+    //    int offset = 0;
+    copyOfNumber = number;
+    if (number < 0) {
+        isNegative = 1;
+        number = 0 - number;
+        length++;
+    }
+    while (copyOfNumber != 0) {
+        length++;
+        copyOfNumber /= 10;
+    }
+
+    for (divide = 0; divide < length; divide++) {
+        modResult = number % 10;
+        number = number / 10;
+        string[length - (divide + 1)] = modResult + '0';
+    }
+    if (isNegative) {
+        string[0] = '-';
+    }
+    string[length] = '\0';
+    //    return string;
+}
+
+void clientProcTest(int serverPort) {
+    int clientPort;
+    char buf[128];
+    char host[16] = "localhost";
+
+    // sleep for 100 clock ticks to ensure that the server process starts first.
+    sleep(100);
+
+    printf(1, "Client>> pid = %d, Attempting to connect to port %d, host %s ...\n", getpid(), serverPort, host);
+    clientPort = connect(serverPort, host); // [ Here the socket of server oitao connected, client socket also connected ]
+    if (clientPort == 127) {
+        sleep(10000); //Just for testing
+    }
+    sleep(20);
+    printf(1, "Client>> pid = %d, connect() returned %d\n", getpid(), clientPort);
+    int count = 0;
+    while (1) {
+        if (clientPort < 0) {
+            //            break;
+        }
+        count++;
+        //        sprintf(str_count, " %d", count);
+        char str_count[10];
+        integer_to_string(str_count, count);
+        strcpy(buf + 0, "MessageSending_");
+        strcpy(buf + strlen(buf), str_count);
+        printf(1, "Client pid = %d >>, message to send = %s\n", getpid(), buf);
+        //        gets(buf, sizeof (buf));
+        buf[strlen(buf) - 1] = '\0'; // Eliminating the '\n'
+
+        send(clientPort, buf, strlen(buf) + 1);
+
+        if (0 == strcmp(buf, "exit")) {
+            printf(1, "Client pid = %d, exiting...\n\n", getpid());
+            disconnect(clientPort);
+            break;
+        }
+
+        sleep(100 + uptime() % 100);
+        char recvBuf[128];
+        recv(clientPort, recvBuf, sizeof (recvBuf));
+        printf(1, "Client pid = %d>> Received: \"%s\"\n\n", getpid(), recvBuf);
+
+    }
+}
+
+void test1() {
+    int p1 = 10;
+    int x; // y; // z;
+    x = fork();
+    //    y = fork();
+    //    z = fork();
+    if (x == 0) {
+
+        clientProc(p1);
+        exit();
+    } else {
+        int f = send(p1, "Hi", 2);
+        f = checkError(f);
+        serverProc(p1);
+        wait();
+        exit();
+    }
+}
+
+void test2() {
+    int x, y, z;
+    x = fork();
+    y = fork();
+    z = fork();
+    int p1 = 2;
+    int p2 = 10;
+    int p3 = 15;
+    if (z == 0 && x == 0 && y == 0) {
+        printf(1, "Inside Cond 1st, pid = %d\n", getpid());
+        clientProc(p1);
+        exit();
+    } else if (z == 0 && x == 0 && y != 0) {
+        printf(1, "Inside Cond 2nd, pid = %d\n", getpid());
+        clientProc(p1);
+        exit();
+    } else if (z == 0 && x != 0 && y == 0) {
+        printf(1, "Inside Cond 3rd, pid = %d\n", getpid());
+        clientProc(p2);
+        exit();
+    } else if (z == 0 && x != 0 && y != 0) {
+        printf(1, "Inside Cond 4th, pid = %d\n", getpid());
+        serverProc(p2);
+        wait(); // ??
+        exit();
+    } else if (z != 0 && x == 0 && y == 0) {
+        printf(1, "Inside Cond 5th, pid = %d\n", getpid());
+        clientProc(p3);
+        exit();
+    } else if (z != 0 && x == 0 && y != 0) {
+        printf(1, "Inside Cond 6th, pid = %d\n", getpid());
+        serverProc(p3);
+        wait();
+        exit();
+    } else if (z != 0 && x != 0 && y == 0) {
+        printf(1, "Inside Cond 7th, pid = %d\n", getpid());
+        exit();
+    } else if (z != 0 && x != 0 && y != 0) {
+        printf(1, "Inside Cond 8th, pid = %d\n", getpid());
+        serverProc(p1);
+        wait();
+        exit();
+    }
+}
+
+int main(int argc, char *argv[]) {
+    printf(1, "In Main function ... \n");
+    //    test2();
+    test1();
+
+}
+/*
+     Send test 1
+      int main(int argc, char *argv[]) {
+        int x, y, z;
+        z = fork();
+        x = fork();
+        y = fork();
+
+        if (z == 0 && x == 0 && y == 0) {
+            //        printf(1, "\n\n");
+            listen_test(22);
+            while (1);
+        } else if (z == 0 && x == 0 && y != 0) {
+            while (1);
+        } else if (z == 0 && x != 0 && y == 0) {
+            sleep(150);
+            int clientPort = connect_test(22);
+            char buf[128] = "Hello first try\0";
+            printf(1, "\nSend test first one...\n\n");
+            send(clientPort, buf, strlen(buf) + 1);
+            //Trying to send again ...
+            sleep(400);
+        
+            while (1);
+        } else if (z == 0 && x != 0 && y != 0) {
+            sleep(300);
+            connect_test(22);
+            while (1);
+        } else if (z != 0 && x == 0 && y == 0) {
+            sleep(450);
+            char buf[128] = "Hello SECOND try\0";
+            printf(1, "\nSend test second one...\n\n");
+            int clientPort = 150;
+            int x = send(clientPort, buf, strlen(buf) + 1);
+            printf(1, "User prog, returned x from send ( ) is %d\n", x);
+            while (1);
+        } else if (z != 0 && x == 0 && y != 0) {
+            sleep(550);
+            char buf[128] = "Hello THURD try\0";
+            printf(1, "\nSend test third one with port = 127 [Should give ACCESS_DENIED]...\n\n");
+            int clientPort = 127;
+            int x = send(clientPort, buf, strlen(buf) + 1);
+            printf(1, "User prog, returned x from send ( ) is %d\n", x);
+            while (1);
+        }        //    else if (z != 0 && x != 0 && y == 0) {
+
+            //    }
+        else {
+            while (1);
+        }
+
+    }
+ 
+ */
+/*
+ //Connect_test
+ * 
+     int x, y, z;
+    z = fork();
+    x = fork();
+    y = fork();
+
+    if (z == 0 && x == 0 && y == 0) {
+        printf(1, "\n\n");
+        listen_test(22);
+        while (1);
+    } else if (z == 0 && x == 0 && y != 0) {
+        sleep(100);
+        listen_test(21);
+        while (1);
+    } else if (z == 0 && x != 0 && y == 0) {
+        sleep(150);
+        connect_test(22);
+        while (1);
+    } else if (z == 0 && x != 0 && y != 0) {
+        sleep(250);
+        connect_test(21);
+        while (1);
+    } else if (z != 0 && x == 0 && y == 0) {
+        sleep(300);
+        connect_test(21);
+    } else if(z != 0 && x == 0 && y != 0){
+        sleep(350);
+        connect_test(50);
+    }
+    else {
+        while (1);
+    }
+
+ */
+
+/*
+ * LISTEN Test
+ * int main(int argc, char *argv[]) {
+    int x, y;
+    x = fork();
+    y = fork();
+    if (x == 0 && y == 0) {
+        printf(1, "\n\n");
+        listen_test(22);
+        while (1);
+
+    } else if (x == 0 && y != 0) {
+        sleep(500);
+        listen_test(21);
+        while (1);
+    } else if (x != 0 && y == 0) {
+        sleep(900);
+        listen_test(22);
+        while (1);
+    } else {
+        while (1);
+    }
+
+} 
+ */
diff --git a/syscall.c b/syscall.c
index ee85261..c06bb58 100644
--- a/syscall.c
+++ b/syscall.c
@@ -60,7 +60,7 @@ argptr(int n, char **pp, int size)
 {
   int i;
   struct proc *curproc = myproc();
- 
+
   if(argint(n, &i) < 0)
     return -1;
   if(size < 0 || (uint)i >= curproc->sz || (uint)i+size > curproc->sz)
@@ -103,6 +103,11 @@ extern int sys_unlink(void);
 extern int sys_wait(void);
 extern int sys_write(void);
 extern int sys_uptime(void);
+extern int sys_listen(void);
+extern int sys_connect(void);
+extern int sys_send(void);
+extern int sys_recv(void);
+extern int sys_disconnect(void);
 
 static int (*syscalls[])(void) = {
 [SYS_fork]    sys_fork,
@@ -126,6 +131,11 @@ static int (*syscalls[])(void) = {
 [SYS_link]    sys_link,
 [SYS_mkdir]   sys_mkdir,
 [SYS_close]   sys_close,
+[SYS_listen]  sys_listen,
+[SYS_connect] sys_connect,
+[SYS_send]    sys_send,
+[SYS_recv]    sys_recv,
+[SYS_disconnect] sys_disconnect
 };
 
 void
diff --git a/syscall.h b/syscall.h
index bc5f356..289fb4b 100644
--- a/syscall.h
+++ b/syscall.h
@@ -20,3 +20,8 @@
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
+#define SYS_listen  22
+#define SYS_connect  23
+#define SYS_send  24
+#define SYS_recv  25
+#define SYS_disconnect  26
diff --git a/syssock.c b/syssock.c
new file mode 100644
index 0000000..bae43c5
--- /dev/null
+++ b/syssock.c
@@ -0,0 +1,109 @@
+#include "types.h"
+#include "defs.h"
+#include "param.h"
+#include "memlayout.h"
+#include "mmu.h"
+#include "x86.h"
+#include "proc.h"
+//#include "user.h"   //To include the error codes ... ?? for now they in param.h
+
+int
+sys_listen(void) {
+    int port = 0;
+    argint(0, &port); //First argument is the port number
+
+    if (port < 0 || port >= NPORT) {
+        return E_INVALID_ARG; //Invalid arguments
+    }
+
+    return listen(port);
+}
+
+int
+sys_connect(void) {
+    int port = 0;
+    char *host = 0;
+
+    // Allow connection to "localhost" or "127.0.0.1" host only
+
+
+    argint(0, &port); //First argument is the port number
+    argstr(1, &host); //Second arg is the host
+
+    if (!((strncmp(host, "localhost", 9) == 0) || (strncmp(host, "127.0.0.1", 9) == 0))) {
+        //Invalid Argument of host
+        return E_INVALID_ARG;
+    }
+    if (port < 0 || port >= NPORT) {
+        //Invalid argument of port number
+        return E_INVALID_ARG;
+    }
+
+    return connect(port, host);
+}
+
+int
+sys_send(void) {
+    int port = 0;
+    char* buf = 0;
+    int n = 0;
+
+
+    // Code to get and validate port no., buffer and buffer size
+
+    argint(0, &port); //First argument is the port number
+    int ret = argstr(1, &buf); //Second arg is the buffer
+    argint(2, &n); //Third arg is the buffer size
+
+    if(ret < 0){    //
+        return E_INVALID_ARG ;
+    }
+    if (n <= 0 || n > MAX_BUFFER_SIZE_SOCKET) {
+        return E_INVALID_ARG;
+    }
+    if (port < 0 || port >= NPORT) {
+        return E_INVALID_ARG;
+    }
+    //Buffer validation ?? 
+
+    return send(port, buf, n);
+}
+
+int
+sys_recv(void) {
+    int port = 0;
+    char* buf = 0;
+    int n = 0;
+
+    // Code to get and validate port no., buffer and buffer size
+
+    argint(0, &port); //First argument is the port number
+    int returnedVal = argstr(1, &buf); //Second arg is the buffer
+    argint(2, &n); //Third arg is the buffer size
+
+    if(returnedVal < 0){
+        return E_INVALID_ARG ;  //Problem has occured with argstr .... so error
+    }
+    if (n <= 0 || n > MAX_BUFFER_SIZE_SOCKET) {
+        return E_INVALID_ARG;
+    }
+    if (port < 0 || port >= NPORT) {
+        return E_INVALID_ARG;
+    }
+
+    return recv(port, buf, n);
+}
+
+int
+sys_disconnect(void) {
+    int port = 0;
+
+    argint(0, &port); //First argument is the port number
+    // Code to get and validate port no.
+    if (port < 0 || port >= NPORT) {
+        return E_INVALID_ARG;
+    }
+
+
+    return disconnect(port);
+}
diff --git a/user.h b/user.h
index 4f99c52..4663a37 100644
--- a/user.h
+++ b/user.h
@@ -1,6 +1,8 @@
+#include "socketThings.h"   //To include the error codes ...
 struct stat;
 struct rtcdate;
 
+
 // system calls
 int fork(void);
 int exit(void) __attribute__((noreturn));
@@ -23,6 +25,11 @@ int getpid(void);
 char* sbrk(int);
 int sleep(int);
 int uptime(void);
+int listen(int);
+int connect(int, const char* host);
+int send(int, const char*, int);
+int recv(int, char*, int);
+int disconnect(int);
 
 // ulib.c
 int stat(const char*, struct stat*);
diff --git a/usys.S b/usys.S
index 8bfd8a1..2ac5ed0 100644
--- a/usys.S
+++ b/usys.S
@@ -29,3 +29,9 @@ SYSCALL(getpid)
 SYSCALL(sbrk)
 SYSCALL(sleep)
 SYSCALL(uptime)
+SYSCALL(listen)
+SYSCALL(connect)
+SYSCALL(send)
+SYSCALL(recv)
+SYSCALL(disconnect)
+
diff --git a/xv6_SocketStub_patch_sir b/xv6_SocketStub_patch_sir
new file mode 100644
index 0000000..aebc3cd
--- /dev/null
+++ b/xv6_SocketStub_patch_sir
@@ -0,0 +1,419 @@
+commit 02195eee285ee63f3aae983a85a6fdaec47fafd6
+Author: Saifur Rahman <saifur80@gmail.com>
+Date:   Sun Jan 13 22:07:13 2019 +0600
+
+    xv6 Socket API stub for students
+
+diff --git a/Makefile b/Makefile
+index 09d790c..e011a93 100644
+--- a/Makefile
++++ b/Makefile
+@@ -16,12 +16,14 @@ OBJS = \
+ 	pipe.o\
+ 	proc.o\
+ 	sleeplock.o\
++	sock.o\
+ 	spinlock.o\
+ 	string.o\
+ 	swtch.o\
+ 	syscall.o\
+ 	sysfile.o\
+ 	sysproc.o\
++	syssock.o\
+ 	trapasm.o\
+ 	trap.o\
+ 	uart.o\
+@@ -181,6 +183,7 @@ UPROGS=\
+ 	_usertests\
+ 	_wc\
+ 	_zombie\
++	_socktest\
+ 
+ fs.img: mkfs README $(UPROGS)
+ 	./mkfs fs.img README $(UPROGS)
+diff --git a/defs.h b/defs.h
+index 82fb982..ae6ae7e 100644
+--- a/defs.h
++++ b/defs.h
+@@ -121,6 +121,14 @@ int             wait(void);
+ void            wakeup(void*);
+ void            yield(void);
+ 
++// sock.c
++void            sinit(void);
++int             listen(int);
++int             connect(int, const char*);
++int             send(int, const char*, int);
++int             recv(int, char*, int);
++int             disconnect(int);
++
+ // swtch.S
+ void            swtch(struct context**, struct context*);
+ 
+diff --git a/main.c b/main.c
+index 9924e64..ac0b23e 100644
+--- a/main.c
++++ b/main.c
+@@ -4,6 +4,7 @@
+ #include "memlayout.h"
+ #include "mmu.h"
+ #include "proc.h"
++#include "sock.h"
+ #include "x86.h"
+ 
+ static void startothers(void);
+@@ -27,10 +28,11 @@ main(void)
+   consoleinit();   // console hardware
+   uartinit();      // serial port
+   pinit();         // process table
++  sinit();         // socket table
+   tvinit();        // trap vectors
+   binit();         // buffer cache
+   fileinit();      // file table
+-  ideinit();       // disk 
++  ideinit();       // disk
+   startothers();   // start other processors
+   kinit2(P2V(4*1024*1024), P2V(PHYSTOP)); // must come after startothers()
+   userinit();      // first user process
+diff --git a/param.h b/param.h
+index a7e90ef..f8e5027 100644
+--- a/param.h
++++ b/param.h
+@@ -1,3 +1,5 @@
++#define NPORT       128  // maximum number of ports
++#define NSOCK        32  // maximum number of sockets
+ #define NPROC        64  // maximum number of processes
+ #define KSTACKSIZE 4096  // size of per-process kernel stack
+ #define NCPU          8  // maximum number of CPUs
+diff --git a/sock.c b/sock.c
+new file mode 100644
+index 0000000..4d92581
+--- /dev/null
++++ b/sock.c
+@@ -0,0 +1,70 @@
++#include "types.h"
++#include "defs.h"
++#include "param.h"
++#include "spinlock.h"
++#include "sock.h"
++#include "memlayout.h"
++#include "mmu.h"
++#include "x86.h"
++#include "proc.h"
++
++//
++// TODO: Create a structure to maintain a list of sockets
++// Should it have locking?
++//
++
++void
++sinit(void)
++{
++  //
++  // TODO: Write any initialization code for socket API
++  // initialization.
++  //
++}
++
++int
++listen(int lport) {
++
++  //
++  // TODO: Put the actual implementation of listen here.
++  //
++
++  return 0;
++}
++
++int
++connect(int rport, const char* host) {
++  //
++  // TODO: Put the actual implementation of connect here.
++  //
++
++  return 0;
++}
++
++int
++send(int lport, const char* data, int n) {
++  //
++  // TODO: Put the actual implementation of send here.
++  //
++
++  return 0;
++}
++
++
++int
++recv(int lport, char* data, int n) {
++  //
++  // TODO: Put the actual implementation of recv here.
++  //
++
++  return 0;
++}
++
++int
++disconnect(int lport) {
++  //
++  // TODO: Put the actual implementation of disconnect here.
++  //
++
++  return 0;
++}
+diff --git a/sock.h b/sock.h
+new file mode 100644
+index 0000000..2ab24fe
+--- /dev/null
++++ b/sock.h
+@@ -0,0 +1,8 @@
++
++//
++// TODO: Define an enumeration to represent socket state.
++//
++
++//
++// TODO: Define a structure to represent a socket.
++//
+diff --git a/socktest.c b/socktest.c
+new file mode 100644
+index 0000000..b68a705
+--- /dev/null
++++ b/socktest.c
+@@ -0,0 +1,77 @@
++#include "types.h"
++#include "user.h"
++
++int serverPort = 10;
++
++void clientProc() {
++  int clientPort;
++  char buf[128];
++  char host[16] = "localhost";
++
++  // sleep for 100 clock ticks to ensure that the server process starts first.
++  sleep(100);
++
++  printf(1, "Client>> Attempting to connect to port %d, host %s ...\n", serverPort, host);
++  clientPort = connect(serverPort, host);
++  sleep(20);
++  printf(1, "Client>> connect() returned %d\n", clientPort);
++
++  while (1) {
++    printf(1, "Client>> Enter text to send to server: ");
++    gets(buf, sizeof(buf));
++    buf[strlen(buf) - 1] = '\0'; // Eliminating the '\n'
++    send(clientPort, buf, strlen(buf) + 1);
++
++    if (0 == strcmp(buf, "exit")) {
++      printf(1, "Client exiting...\n");
++      disconnect(clientPort);
++      break;
++    }
++
++    sleep(100 + uptime() % 100);
++
++    recv(clientPort, buf, sizeof(buf));
++    printf(1, "Client>> Received: \"%s\"\n", buf);
++  }
++}
++
++void serverProc() {
++  int status;
++  char buf[128];
++
++  printf(1, "Server>> Starting to listen at port %d ...\n", serverPort);
++  status = listen(serverPort);
++  printf(1, "Server>> listen() returned %d\n", status);
++
++  while (1) {
++    sleep(100 + uptime() % 100);
++
++    recv(serverPort, buf, sizeof(buf));
++    printf(1, "Server>> Received: \"%s\"\n", buf);
++
++    if (0 == strcmp(buf, "exit")) {
++      printf(1, "Server exiting...\n");
++      disconnect(serverPort);
++      break;
++    }
++
++    sleep(100 + uptime() % 100);
++
++    strcpy(buf+strlen(buf), " OK");
++    send(serverPort, buf, strlen(buf) + 1);
++  }
++}
++
++
++int main(int argc, char *argv[])
++{
++  if (0 == fork()) {
++    clientProc();
++    exit();
++  } else {
++    serverProc();
++    // This is the parent process. So, it needs to wait before client terminates
++    wait();
++    exit();
++  }
++}
+diff --git a/syscall.c b/syscall.c
+index ee85261..c06bb58 100644
+--- a/syscall.c
++++ b/syscall.c
+@@ -60,7 +60,7 @@ argptr(int n, char **pp, int size)
+ {
+   int i;
+   struct proc *curproc = myproc();
+- 
++
+   if(argint(n, &i) < 0)
+     return -1;
+   if(size < 0 || (uint)i >= curproc->sz || (uint)i+size > curproc->sz)
+@@ -103,6 +103,11 @@ extern int sys_unlink(void);
+ extern int sys_wait(void);
+ extern int sys_write(void);
+ extern int sys_uptime(void);
++extern int sys_listen(void);
++extern int sys_connect(void);
++extern int sys_send(void);
++extern int sys_recv(void);
++extern int sys_disconnect(void);
+ 
+ static int (*syscalls[])(void) = {
+ [SYS_fork]    sys_fork,
+@@ -126,6 +131,11 @@ static int (*syscalls[])(void) = {
+ [SYS_link]    sys_link,
+ [SYS_mkdir]   sys_mkdir,
+ [SYS_close]   sys_close,
++[SYS_listen]  sys_listen,
++[SYS_connect] sys_connect,
++[SYS_send]    sys_send,
++[SYS_recv]    sys_recv,
++[SYS_disconnect] sys_disconnect
+ };
+ 
+ void
+diff --git a/syscall.h b/syscall.h
+index bc5f356..289fb4b 100644
+--- a/syscall.h
++++ b/syscall.h
+@@ -20,3 +20,8 @@
+ #define SYS_link   19
+ #define SYS_mkdir  20
+ #define SYS_close  21
++#define SYS_listen  22
++#define SYS_connect  23
++#define SYS_send  24
++#define SYS_recv  25
++#define SYS_disconnect  26
+diff --git a/syssock.c b/syssock.c
+new file mode 100644
+index 0000000..4c006af
+--- /dev/null
++++ b/syssock.c
+@@ -0,0 +1,73 @@
++#include "types.h"
++#include "defs.h"
++#include "param.h"
++#include "memlayout.h"
++#include "mmu.h"
++#include "x86.h"
++#include "proc.h"
++
++int
++sys_listen(void)
++{
++  int port = 0;
++
++  //
++  // TODO: Write your code to get and validate port no.
++  //
++
++  return listen(port);
++}
++
++int
++sys_connect(void)
++{
++  int port = 0;
++  char *host = 0;
++
++  //
++  // TODO: Write your code to get and validate port no., host.
++  // Allow connection to "localhost" or "127.0.0.1" host only
++  //
++
++  return connect(port, host);
++}
++
++int
++sys_send(void)
++{
++  int port = 0;
++  char* buf = 0;
++  int n = 0;
++
++  //
++  // TODO: Write your code to get and validate port no., buffer and buffer size
++  //
++
++  return send(port, buf, n);
++}
++
++int
++sys_recv(void)
++{
++  int port = 0;
++  char* buf = 0;
++  int n = 0;
++
++  //
++  // TODO: Write your code to get and validate port no., buffer and buffer size
++  //
++
++  return recv(port, buf, n);
++}
++
++int
++sys_disconnect(void)
++{
++  int port = 0;
++
++  //
++  // TODO: Write your code to get and validate port no.
++  //
++
++  return disconnect(port);
++}
+diff --git a/user.h b/user.h
+index 4f99c52..ce9f2f1 100644
+--- a/user.h
++++ b/user.h
+@@ -23,6 +23,11 @@ int getpid(void);
+ char* sbrk(int);
+ int sleep(int);
+ int uptime(void);
++int listen(int);
++int connect(int, const char* host);
++int send(int, const char*, int);
++int recv(int, char*, int);
++int disconnect(int);
+ 
+ // ulib.c
+ int stat(const char*, struct stat*);
+diff --git a/usys.S b/usys.S
+index 8bfd8a1..2ac5ed0 100644
+--- a/usys.S
++++ b/usys.S
+@@ -29,3 +29,9 @@ SYSCALL(getpid)
+ SYSCALL(sbrk)
+ SYSCALL(sleep)
+ SYSCALL(uptime)
++SYSCALL(listen)
++SYSCALL(connect)
++SYSCALL(send)
++SYSCALL(recv)
++SYSCALL(disconnect)
++
