;Bubble Sort
;3 5 1 6 -10 3 78 36 86 35 30
.MODEL SMALL 
.STACK 100h
.DATA 
ARR DW 16 DUP(-1)
WORD1 DW 0
SIZE_ARR DW 1
VAR_I DW 0
VAR_J DW 0
SWAPPED DB 0
NUM1 DW 0
NUM2 DW 0  
TEMP DW 0 
TERMINATOR DW 0 
INPUT_MSG DW 'Enter Input Array: $'
OUTPUT_MSG DW 'Sorted Array: $'
.CODE
NEWLINE PROC 
	PUSH AX 
	PUSH DX 
	MOV AH, 2
	MOV DL, 13 
	INT 21h 
	MOV DL, 10 
	INT 21h 
	POP DX 
	POP AX
	RET 
NEWLINE ENDP 

SPACE PROC 
	PUSH AX 
	PUSH DX 
	
	MOV AH, 2
	MOV DL, ' '
	INT 21h 
	
	POP DX 
	POP AX 
	RET 
SPACE ENDP
BUUBLESORT PROC 
	;SI = ARRAY OFFSET ADDRESS, AND BX = NUM OF ELEMENTS 
	;PUSH REGISTERS BEGIN 
	PUSH AX 
	PUSH BX 
	PUSH CX
	PUSH DX
	PUSH SI 
	;PUSH REGISTERS END	

	MOV DI, SI	;DI CONTAINS POINTER SI 
	
	MOV SIZE_ARR, BX 
	DEC SIZE_ARR ; SIZE_ARR = n - 1 
	
	MOV AH, 0 ; -AH IS THE FLAG HERE , SWAP = FALSE 
	
	MOV CX, SIZE_ARR 
	LOOP1:
		MOV AX, CX 
 
		MOV AH, 0 ; FLAG = FALSE  
		MOV VAR_J, 0 ; j = 0 
        MOV BX, 0 ; TO STORE THE POINTER i.e j IN THE REG BX 		
		LOOP_2: 	
			MOV DX, ARR[BX]	
			MOV NUM1, DX ;num1 = arr[j]

			MOV DX, ARR[BX + 2]	; + 2 IS DONE BECAUSE Word TYPE HAS S = 2 
			MOV NUM2, DX ;num2 = arr[j+1]
			
			MOV DX, NUM1 ;COMPARE TWO NUMS USE DX AS INTERMEDIATE REG  
			CMP DX, NUM2 ; 
			
			JG IF_BRANCH 
			JMP END_IF 
			
		IF_BRANCH: 
			;DX IS USED AS TEMP REGISTER 
			MOV DX, NUM2 
			MOV ARR[BX], DX 
			MOV DX, NUM1 
			MOV ARR[BX + 2], DX ;SWAP OPERATION USE DX AS INTERMEDIATE REG AND EXCHANGE A[j] WITH A[j+1]
			
			MOV AH, 1 ; SWAP = TRUE
			
		END_IF:    
		    MOV DX, VAR_J
		    INC DX 
		    MOV VAR_J, DX			;j++ USE DX AS TEMP REG 
			
			;CHECK IF (j == (n - i - 1))
			;MOV TEMP, BX 
			MOV DX, SIZE_ARR			
			SUB DX, VAR_I ; n - i 
			ADD BX, 2
			CMP VAR_J, DX 
			JNZ LOOP_2
			
		INC VAR_I ; i++ IN THE END
		MOV DX, BX 
		DEC DX 
		CMP VAR_I, DX  ; CHECK i WITH n - 1
		JZ END_LABEL 
		
		;ALSO CHECK swap == FALSE CONDITION 
		CMP AH, 0
		JZ END_LABEL 
		
		ADD DI, 2 		
		DEC CX 
		CMP CX, 0
		
		JE END_LABEL
		JMP LOOP1
END_LABEL: 
	;POP REGISTERS BEGIN

	POP SI 
	POP DX 
	POP CX 
	POP BX
	POP AX 

	;POP REGISTERS END 
	RET 
BUUBLESORT ENDP


OUTDEC PROC 
	;INPUT : AX 
	PUSH AX 
	PUSH BX 
	PUSH CX 
	PUSH DX
	
;IF AX < 0 i.e FOR NEG NUMBER 
	CMP AX, 0 
	JNL END_IF1 
;THEN 
	PUSH AX ; SAVE THE NUMBER 
	MOV DL, '-'
	MOV AH, 2 
	INT 21h 
	POP AX 	;POP AX TO GET IT BACK 
	NEG AX ; AX = NOW -AX 
	
END_IF1: 
;TURN TO DECIMAL DIGITS 
	;MOV CX, 0 ; CX HAS DIGITS 
	XOR CX, CX 
	MOV BX, 10D; BX IS THE DIVISOR 
	
REPEAT:
	;MOV DX, 0 ; DIVIDEND PREPARATION
	XOR DX, DX 
	DIV BX ; AX HAS QUOTIENT, DX HAS REMAINDER
	PUSH DX 
	INC CX ;STORES THE COUNT 
;REPEAT UNTIL QUOTIENT = 0 
	;CMP AX, 0
	OR AX, AX 
	JNE REPEAT 

;CONVERT TO CHAR AND PRINT ON SCRN 
	MOV AH, 2 

PRINTER: 
	POP DX ; DIGIT IS NOW IN DL REG 
	OR DL, 30h	;CONVERT TO CHAR 
	INT 21h 
	LOOP PRINTER 
	
;POP REGISTERS AT THE END 
	POP DX 
	POP CX 
	POP BX 
	POP AX 
 
 
	RET 
OUTDEC ENDP

;TAKE INPUT (DOESNOT HANDLE FOR OUT OF RANGE CHARS)
INPUT PROC 
;READ A NUMBER INPUT : NOTHING, OUTPUT : AX (SIGNED) AND CX HAS THE SIGN 
;SAVE REGISTERS 
	PUSH BX
	PUSH CX 
	PUSH DX 
;SAVE REGISTERS DONE 
BEGIN_IN_LABEL: 
;BX HOLDS TOTAL 
	MOV BX, 0
;CX HOLDS SIGN (INTIALLY ZERO i.e ASSUMING POSITIVE)
	MOV CX, 0
;READ A CHAR 
	MOV AH, 1
	INT 21h 
;CHECK IF IT IS 'x' THEN GO TO END IN MAIN 
	CMP AL, 'x'
	JE LABEL_ENDINPUT
;CHECK IF IT IS '-' SIGN 
	CMP AL, '-'
	JE NEG_NUMBER_LABEL
	JMP POSITIVE_LABEL
;IF NOT THEN THIS DIGIT IS A NUMBER 
NEG_NUMBER_LABEL: 
	MOV CX, 1 
	JMP REPEAT_LABEL
	
POSITIVE_LABEL:	;FIRST CHAR IS A NUMBER IN POSITIVE SO CONVERT IT ACCORDINGLY
	AND AX, 00FH	;CONVERT CHAR TO DIGIT 
	PUSH AX 
	MOV AX, 10
	MUL BX ; AX = TOTAL * 10 
	POP BX 
	ADD BX, AX ;TOTAL = TOTAL * 10 + DIGIT 

REPEAT_LABEL: 	
	MOV AH, 1 ;KEEP TAKING INPUTS UNTIL 'x' IS FOUND 
	INT 21h 
	CMP AL, 'x'
	MOV TERMINATOR, 1 ; TERMINATOR FLAG IS 1  
	JE PROCESSING_LABEL
	MOV TERMINATOR, 0 ; TERMINATOR FLAG IS RESTORED TO 0 
	CMP AL, ' '
	JE PROCESSING_LABEL 

	AND AX, 00FH	;CONVERT CHAR TO DIGIT 
	PUSH AX 
	MOV AX, 10
	MUL BX ; AX = TOTAL * 10 
	POP BX 
	ADD BX, AX ;TOTAL = TOTAL * 10 + DIGIT 
	JMP REPEAT_LABEL 

PROCESSING_LABEL: 
	MOV AX, BX ; STORE NUM IN AX 
	CMP CX, 0 ; IS IT POSITIVE NUMBER ?? 
	JE END_LABEL_INPUT ; IF SO THEN EXIT OTHERWISE MAKE 2'S COMPLEMENT
	NEG AX 
	;END IF 
	
END_LABEL_INPUT: 
;POP REGISTERS 
	POP DX 
	POP CX 
	POP BX

;POP REGISTERS DONE
	RET 
INPUT ENDP 

MAIN PROC 

	MOV DX, @DATA 
	MOV DS, DX 

;PROMPT INPUT 	
	LEA DX, INPUT_MSG
	MOV AH, 9
	INT 21h 
;PROMPT INPUT DONE 


;LOAD ARRAY OFFSET IN SI 
	LEA SI, ARR 
;CALL INPUT PROC 
LABEL_MAIN_1:
	CMP TERMINATOR, 1 ; NEED TO END NOW 
	JE LABEL_ENDINPUT
	CALL INPUT
LABEL_MAIN_REP:
	;AX STORES THE INPUT NUM HERE ... 
	MOV [SI], AX 
	ADD SI, 2 ;MOVE TO NEXT ARRAY POINTER 
	INC SIZE_ARR ;INCREMENT THE SIZE OF ARRAY 
	JMP LABEL_MAIN_1
;HERE AX STORES THE NUMBER 
	;PUSH AX ; PUSH AX ONTO THE STACK FOR FUTURE POP 
	
	;CALL NEWLINE

;AX SHOULD STORE THE NUMBER
	;POP AX 

LABEL_ENDINPUT: 
;DECREMENT SIZE BY 1 TO AVOID THE FINAL 'x'
	DEC SIZE_ARR 
	
	;PRINTING THE SIZE OF ARRAY AND THEN ITS ELEMENTS 
	;CALL NEWLINE 
	;MOV AX, SIZE_ARR
	;CALL OUTDEC 
	;CALL NEWLINE
	


	
	
;CALL THE PROCEDURE BUUBLESORT , MAKE SURE BX HAS THE SIZE OF ARRAY 
	MOV BX, SIZE_ARR 
	CALL BUUBLESORT 
	
	
	CALL NEWLINE
;PROMPT OUTPUT  	
	LEA DX, OUTPUT_MSG
	MOV AH, 9
	INT 21h 
;PROMPT OUTPUT  DONE 
	
;PRINTIN THE ARRAY 
	LEA SI, ARR 
	MOV CX, SIZE_ARR
	INC CX 
PRINT_ARR_MAIN: 
	MOV AX, [SI]
	CALL OUTDEC
	ADD SI, 2
	CALL SPACE 
 
	LOOP PRINT_ARR_MAIN

	

;RETURN TO DOS 
	MOV AH, 4CH
	INT 21h 

MAIN ENDP 
END MAIN 
